CHIP HalfAdder {
    IN a, b;    // 1-bit inputs
    OUT sum,    // Right bit of a + b 
        carry;  // Left bit of a + b
    PARTS:
    Xor(a= a, b= b, out= sum);
    And(a= a, b= b, out= carry);
}

CHIP FullAdder {
    IN a, b, c;  // 1-bit inputs
    OUT sum,     // Right bit of a + b + c
        carry;   // Left bit of a + b + c
    PARTS:
    HalfAdder(a= a, b= b, sum= sum1, carry= c1);
    HalfAdder(a= sum1, b= c, sum= sum, carry= c2);
    Or(a= c1, b= c2, out= carry);
}

CHIP Add16 {
    IN a[16], b[16];
    OUT out[16];
    PARTS:
    HalfAdder(a= a[0], b= b[0], sum= out[0], carry= c1);
    FullAdder(a= a[1], b= b[1], c= c1, sum= out[1], carry= c2);
    FullAdder(a= a[2], b= b[2], c= c2, sum= out[2], carry= c3);
    FullAdder(a= a[3], b= b[3], c= c3, sum= out[3], carry= c4);
    FullAdder(a= a[4], b= b[4], c= c4, sum= out[4], carry= c5);
    FullAdder(a= a[5], b= b[5], c= c5, sum= out[5], carry= c6);
    FullAdder(a= a[6], b= b[6], c= c6, sum= out[6], carry= c7);
    FullAdder(a= a[7], b= b[7], c= c7, sum= out[7], carry= c8);
    FullAdder(a= a[8], b= b[8], c= c8, sum= out[8], carry= c9);
    FullAdder(a= a[9], b= b[9], c= c9, sum= out[9], carry= c10);
    FullAdder(a= a[10], b= b[10], c= c10, sum= out[10], carry= c11);
    FullAdder(a= a[11], b= b[11], c= c11, sum= out[11], carry= c12);
    FullAdder(a= a[12], b= b[12], c= c12, sum= out[12], carry= c13);
    FullAdder(a= a[13], b= b[13], c= c13, sum= out[13], carry= c14);
    FullAdder(a= a[14], b= b[14], c= c14, sum= out[14], carry= c15);
    FullAdder(a= a[15], b= b[15], c= c15, sum= out[15], carry= c16);
}

CHIP Inc16 {
    IN in[16];
    OUT out[16];
    PARTS:
    Add16(a = in, b[0] = true, out = out);
}

CHIP ALU {
    IN  
        x[16], y[16],   // 16-bit inputs        
        zx,             // zero the x input?
        nx,             // negate the x input?
        zy,             // zero the y input?
        ny,             // negate the y input?
        f,              // compute (1: out = x + y) or (0: out = x & y)?
        no;             // negate the out output?
    OUT 
        out[16],        // 16-bit output
        zr,             // if (out == 0) equals 1, else 0
        ng;             // if (out < 0)  equals 1, else 0
    PARTS:
    // zx
    Mux16(a=x, b=false, sel=zx, out=o1);
    // nx
    Not16(in=o1, out=noto1);
    Mux16(a=o1, b=noto1, sel=nx, out=o2);
    // zy
    Mux16(a=y, b=false, sel=zy, out=o3);
    // ny
    Not16(in=o3, out=noto3);
    Mux16(a=o3, b=noto3, sel=ny, out=o4);
    // f
    And16(a=o2, b=o4, out=o5);
    Add16(a=o2, b=o4, out=o6);
    Mux16(a=o5, b=o6, sel=f, out=o7);
    // no
    Not16(in=o7, out=noto7);
    // [15] = left-most (+/- sign), [0..7]/[8..15] = to halve 16-bit into 2 Or8Ways
    Mux16(a=o7, b=noto7, sel=no, out=out, out[15]=neg, out[0..7]=firstHalf, out[8..15]=laterHalf);
    // zr
    Or8Way(in=firstHalf, out=o8);
    Or8Way(in=laterHalf, out=o9);
    Or(a=o8, b=o9, out=o10); // if (out == 0) equals 1
    Not(in=o10, out=o11); // else equals 0
    // ng
    And(a=neg, b=true, out=ng);
}